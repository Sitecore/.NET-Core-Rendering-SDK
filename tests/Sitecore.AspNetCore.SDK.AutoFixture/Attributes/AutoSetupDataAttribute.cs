using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using AutoFixture;
using AutoFixture.Xunit2;
using Sitecore.AspNetCore.SDK.AutoFixture.ActionProviders;

namespace Sitecore.AspNetCore.SDK.AutoFixture.Attributes;

[ExcludeFromCodeCoverage]
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property)]
public class AutoSetupDataAttribute : AutoDataAttribute
{
    public const string DefaultFixtureSetupName = "AutoSetup";

    public const string AutoSetupExternalSourceFieldName = "AutoSetupSource";

    private readonly string[] _fixtureSetups;

    private readonly Type? _classSource;

    private readonly IEnumerable<ISetupActionsProvider> _setupActionsProviders;

    /// <summary>
    /// Defines that this test will have its parameter values generated by an AutoFixture <see cref="IFixture"/> instance, which can be
    /// configured by static methods on this fixture class.
    /// </summary>
    /// <param name="fixtureSetups">The names of the public static methods that return <see cref="Action{T}"/> of <see cref="IFixture"/>. 'AutoSetup' is inserted as the first name if it is not specified.</param>
    public AutoSetupDataAttribute(params string[] fixtureSetups)
        : this(null, fixtureSetups)
    {
    }

    /// <summary>
    /// Defines that this test will have its parameter values generated by an AutoFixture <see cref="IFixture"/> instance, which can be
    /// configured by public static methods on a specified class.
    /// </summary>
    /// <param name="externalClassSource">The class containing the public static methods to configure the <see cref="IFixture"/> instance.</param>
    /// <param name="fixtureSetups">The names of the public static methods that return <see cref="Action{T}"/> of <see cref="IFixture"/>. 'AutoSetup' is inserted as the first name if it is not specified.</param>
    public AutoSetupDataAttribute(Type? externalClassSource, params string[] fixtureSetups)
        : this(
            [
                new StaticMethodSetupActionsProvider(),
                new StaticPropertySetupActionsProvider()
            ],
            externalClassSource,
            fixtureSetups)
    {
    }

    protected AutoSetupDataAttribute(
        IEnumerable<ISetupActionsProvider> setupActionsProviders,
        Type? externalClassSource,
        params string[] fixtureSetups)
        : base(() => new Fixture())
    {
        if (fixtureSetups.Length == 0)
        {
            fixtureSetups = [DefaultFixtureSetupName];
        }

        if (!fixtureSetups.Contains(DefaultFixtureSetupName))
        {
            fixtureSetups = [DefaultFixtureSetupName, .. fixtureSetups];
        }

        _fixtureSetups = fixtureSetups;
        _setupActionsProviders = setupActionsProviders;
        _classSource = externalClassSource;
    }

    public override IEnumerable<object[]> GetData(MethodInfo testMethod)
    {
        Type? finalClassSourceType =
            _classSource ??
            GetActionSourceTypeField(testMethod.ReflectedType, AutoSetupExternalSourceFieldName) ??
            GetActionSourceTypeProperty(testMethod.ReflectedType, AutoSetupExternalSourceFieldName) ??
            testMethod.ReflectedType;

        foreach (Action<IFixture> action in GetSetups(finalClassSourceType))
        {
            // We currently need to use this member as we configure the fixture based on the method under test
            // we use the given class to locate the setup members but if null, we use the type from the method under test
#pragma warning disable 0618
            action(Fixture);
#pragma warning restore 0618
        }

        return base.GetData(testMethod);
    }

    protected virtual IEnumerable<Action<IFixture>> GetSetups(Type? functionSourceType)
    {
        List<Action<IFixture>> setupActions = [];

        foreach (string fixtureSetup in _fixtureSetups.Where(a => !string.IsNullOrWhiteSpace(a)))
        {
            List<Action<IFixture>> setups = _setupActionsProviders
                .SelectMany(p => p.GetSetupActions(functionSourceType, fixtureSetup))
                .ToList();

            if (setups.Count == 0 && !fixtureSetup.Equals(DefaultFixtureSetupName, StringComparison.OrdinalIgnoreCase))
            {
                throw new ArgumentOutOfRangeException(fixtureSetup, "No static property, method or field could be found on the test fixture with the name " + fixtureSetup);
            }

            setupActions.AddRange(setups);
        }

        return setupActions;
    }

    private static Type? GetActionSourceTypeField(Type? type, string fieldName)
    {
        FieldInfo? member = type?.GetField(
            fieldName,
            BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);

        if (member == null)
        {
            return null;
        }

        if (member.GetValue(null) is not Type sourceType)
        {
            throw new ArgumentOutOfRangeException(
                $"Field {fieldName} on {type?.FullName} did not return a Type value");
        }

        return sourceType;
    }

    private static Type? GetActionSourceTypeProperty(Type? type, string fieldName)
    {
        PropertyInfo? member = type?.GetProperty(
            fieldName,
            BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);

        if (member == null)
        {
            return null;
        }

        if (member.GetValue(null) is not Type sourceType)
        {
            throw new ArgumentOutOfRangeException(
                $"Property {fieldName} on {type?.FullName} did not return a Type value");
        }

        return sourceType;
    }
}